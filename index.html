<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Lamumu</title>
<style>
  :root { --bg:#9be3ff; --control-size:60px; }
  *{box-sizing:border-box}
  body{
    margin:0;
    min-height:100vh;
    display:flex;
    flex-direction:column;
    align-items:center;
    background:var(--bg);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
    -webkit-tap-highlight-color:transparent;
  }
  header{width:100%;padding:12px 8px;text-align:center}
  .topbar{display:flex;gap:12px;align-items:center;justify-content:center;flex-wrap:wrap}
  select, button, .label {font-size:16px;padding:6px 10px;border-radius:8px;border:1px solid #ccc;background:#fff}
  #score{font-weight:600;margin-left:6px}
  main{width:100%;max-width:1000px;display:flex;flex-direction:column;align-items:center;gap:12px;padding-bottom:80px}
  canvas{display:block;width:100%;height:auto;border-radius:8px;box-shadow:0 8px 20px rgba(0,0,0,0.08)}
  .controls{position:fixed;left:0;right:0;bottom:12px;display:flex;justify-content:center;gap:12px;pointer-events:none}
  .controls .group{pointer-events:auto;display:flex;gap:12px;align-items:center}
  .dir-btn{width:var(--control-size);height:var(--control-size);border-radius:50%;border:none;background:#fff;box-shadow:0 6px 14px rgba(0,0,0,0.12);font-size:20px;display:flex;align-items:center;justify-content:center}
  .small{width:44px;height:44px;font-size:18px}
  .center-col{display:flex;flex-direction:column;align-items:center;gap:10px}
  .muted{color:#3338; font-size:14px}
  .top-right{position:fixed;right:12px;top:12px}
</style>
</head>
<body>
  <header>
    <div class="topbar">
      <div>
        <label class="label">Character:</label>
        <select id="charSelect" aria-label="character">
          <option value="üêÑ">Lamumu (White Cow)</option>
          <option value="üêÇ">Black Cow</option>
          <option value="üêÆ">Calf</option>
          <option value="üêë">Sheep (fun!)</option>
        </select>
      </div>
      <div>
        <button id="startBtn">Start</button>
        <button id="pauseBtn">Pause</button>
      </div>
      <div id="score" class="label">Score: 0</div>
    </div>
    <div class="muted">Use arrows / swipe / buttons to move</div>
  </header>

  <main>
    <canvas id="c"></canvas>
  </main>

  <div class="controls" aria-hidden="true">
    <div class="group center-col">
      <button class="dir-btn small" id="btnUp">‚¨ÜÔ∏è</button>
    </div>
    <div class="group">
      <button class="dir-btn" id="btnLeft">‚¨ÖÔ∏è</button>
      <button class="dir-btn" id="btnDown">‚¨áÔ∏è</button>
      <button class="dir-btn" id="btnRight">‚û°Ô∏è</button>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  // CONFIG
  let px = 28;               // cell size (will be computed on resize)
  const MIN_PX = 20, MAX_PX = 36;
  let speedMs = 110;         // ms per tick (smaller = faster)
  const foodIcon = 'üåø';     // green grass
  let charIcon = 'üêÑ';

  // UI
  const scoreEl = document.getElementById('score');
  const charSelect = document.getElementById('charSelect');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');

  // GAME STATE
  let w=300, h=300;
  let gridW, gridH;
  let snake = []; // array of {x,y}
  let dirX = 1, dirY = 0;
  let food = {x:0,y:0};
  let tail = 5;
  let score = 0;
  let running = false;
  let timer = null;

  // background image (tile). Put image file with this name in same folder:
  const bgImg = new Image();
  bgImg.src = '5832642455453943744.jpg';
  let bgPattern = null;
  let bgReady = false;
  bgImg.onload = () => {
    bgReady = true;
    // create a temporary small canvas pattern on next draw/resize to match devicePixelRatio
    makePattern();
    // if canvas already sized, fill pattern; else wait for resize
  };
  bgImg.onerror = () => { bgReady = false; };

  function makePattern(){
    try{
      // create pattern using the loaded image (repeat)
      bgPattern = ctx.createPattern(bgImg, 'repeat');
    }catch(e){ bgPattern = null; }
  }

  function resize(){
    // compute px relative to screen width for better desktop/mobile balance
    const ww = Math.max(320, window.innerWidth);
    px = Math.max(MIN_PX, Math.min(MAX_PX, Math.floor(ww/30)));
    // canvas pixel size: full width capped
    const maxW = Math.min(window.innerWidth - 24, 1000);
    w = Math.floor(maxW / px) * px || px * 10;
    h = Math.floor((window.innerHeight * 0.68) / px) * px || px * 12;

    // set element size in CSS pixels and backing store size for crisp rendering
    const dpr = window.devicePixelRatio || 1;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    canvas.width = w * dpr;
    canvas.height = h * dpr;
    ctx.setTransform(dpr,0,0,dpr,0,0); // scale drawing operations

    gridW = w / px;
    gridH = h / px;

    // recreate pattern if image loaded (pattern depends on ctx transform)
    if(bgReady) makePattern();

    // reset/center snake
    resetGamePositions();
    drawOnce(); // draw a frame so user sees background immediately
  }

  function resetGamePositions(){
    snake = [];
    tail = 5;
    score = 0;
    dirX = 1; dirY = 0;
    const cx = Math.floor(gridW/2);
    const cy = Math.floor(gridH/2);
    // place snake cells on grid (center)
    for(let i=0;i<tail;i++) snake.push({x: (cx - i)*px, y: cy*px});
    placeFood();
    updateScore();
  }

  function placeFood(){
    // pick random grid-aligned position not on snake
    let tries=0;
    while(true){
      const fx = Math.floor(Math.random()*gridW) * px;
      const fy = Math.floor(Math.random()*gridH) * px;
      const coll = snake.some(s => s.x===fx && s.y===fy);
      if(!coll){ food.x = fx; food.y = fy; break; }
      tries++;
      if(tries>200) { food.x = 0; food.y = 0; break; }
    }
  }

  function updateScore(){
    scoreEl.textContent = 'Score: ' + score;
  }

  // DRAW
  function drawBackground(){
    if(bgReady && bgPattern){
      ctx.fillStyle = bgPattern;
      ctx.fillRect(0,0,w,h);
    } else {
      // fallback: simple diagonal grass lines pattern
      ctx.fillStyle = '#bfeeff';
      ctx.fillRect(0,0,w,h);
      ctx.save();
      ctx.strokeStyle = 'rgba(34,139,34,0.08)';
      ctx.lineWidth = 2;
      for(let y=0;y<h;y+=px/2){
        ctx.beginPath();
        ctx.moveTo(0,y);
        ctx.lineTo(w,(y + 15) % h);
        ctx.stroke();
      }
      ctx.restore();
    }
  }

  function drawOnce(){
    drawBackground();
    // draw food
    ctx.font = px + 'px sans-serif';
    ctx.textBaseline = 'top';
    ctx.fillText(foodIcon, food.x, food.y);
    // draw snake
    for(let seg of snake){
      ctx.fillText(charIcon, seg.x, seg.y);
    }
  }

  function tick(){
    // move head
    const head = snake[snake.length-1];
    let nx = head.x + dirX*px;
    let ny = head.y + dirY*px;
    // wrap
    if(nx < 0) nx = (gridW-1)*px;
    if(nx >= w) nx = 0;
    if(ny < 0) ny = (gridH-1)*px;
    if(ny >= h) ny = 0;

    // check self collision -> reset
    const collidedIndex = snake.findIndex(s => s.x===nx && s.y===ny);
    if(collidedIndex !== -1){
      // game over behavior: reset length and score
      tail = 5;
      score = 0;
      updateScore();
      // reset snake centered
      resetGamePositions();
      return;
    }

    snake.push({x:nx,y:ny});
    while(snake.length > tail) snake.shift();

    // eat food?
    if(nx === food.x && ny === food.y){
      tail++;
      score++;
      updateScore();
      placeFood();
    }

    // redraw
    drawBackground();
    ctx.font = px + 'px sans-serif';
    ctx.textBaseline = 'top';
    // food more visible: draw circle under it
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.beginPath();
    ctx.ellipse(food.x + px/2, food.y + px/2 + 2, px*0.55, px*0.35, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // draw food
    ctx.fillText(foodIcon, food.x, food.y);

    // draw snake
    for(let i=0;i<snake.length;i++){
      const s = snake[i];
      // head highlighted
      if(i===snake.length-1){
        // small halo
        ctx.save();
        ctx.fillStyle = 'rgba(255,255,255,0.15)';
        ctx.beginPath();
        ctx.ellipse(s.x + px/2, s.y + px/2, px*0.7, px*0.55, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
      ctx.fillText(charIcon, s.x, s.y);
    }
  }

  // INPUT
  function setDirection(nx, ny){
    // prevent reverse
    if(dirX === -nx && dirY === -ny) return;
    if(dirX === nx && dirY === ny) return;
    dirX = nx; dirY = ny;
  }

  window.addEventListener('keydown', (e) => {
    if(e.key === 'ArrowLeft') setDirection(-1,0);
    if(e.key === 'ArrowRight') setDirection(1,0);
    if(e.key === 'ArrowUp') setDirection(0,-1);
    if(e.key === 'ArrowDown') setDirection(0,1);
  });

  // on-screen buttons
  document.getElementById('btnLeft').addEventListener('click', () => setDirection(-1,0));
  document.getElementById('btnRight').addEventListener('click', () => setDirection(1,0));
  document.getElementById('btnUp').addEventListener('click', () => setDirection(0,-1));
  document.getElementById('btnDown').addEventListener('click', () => setDirection(0,1));

  // swipe for mobile
  let touchStart = null;
  window.addEventListener('touchstart', (e) => {
    const t = e.touches[0];
    touchStart = {x: t.clientX, y: t.clientY, time: Date.now()};
  }, {passive:true});
  window.addEventListener('touchend', (e) => {
    if(!touchStart) return;
    const t = e.changedTouches[0];
    const dx = t.clientX - touchStart.x;
    const dy = t.clientY - touchStart.y;
    const adx = Math.abs(dx), ady = Math.abs(dy);
    if(Math.max(adx,ady) < 30) { touchStart = null; return; }
    if(adx > ady){
      setDirection(dx>0?1:-1,0);
    } else {
      setDirection(0, dy>0?1:-1);
    }
    touchStart = null;
  }, {passive:true});

  // UI handlers
  charSelect.addEventListener('change', (e) => {
    charIcon = e.target.value;
    drawOnce();
  });

  startBtn.addEventListener('click', () => {
    if(running) return;
    startGame();
  });
  pauseBtn.addEventListener('click', () => {
    stopGame();
  });

  function startGame(){
    if(running) return;
    running = true;
    // clear existing timer just in case
    if(timer) clearInterval(timer);
    timer = setInterval(tick, speedMs);
  }
  function stopGame(){
    running = false;
    if(timer) { clearInterval(timer); timer = null; }
  }

  // ensure canvas gets focus on click so arrow keys work
  canvas.addEventListener('click', ()=> canvas.focus && canvas.focus());

  // Ensure resize on load + ready
  window.addEventListener('resize', resize);

  // initial setup
  resize();
  // don't auto-start until user presses Start; but if you prefer auto-start uncomment:
  // startGame();

})();
</script>
</body>
</html>
